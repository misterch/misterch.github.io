---
title: 模块机制
date: 2023-07-30
---

对于早期的javascript，ECMA的规范很薄弱，有一下缺点

- 没有模块系统
- 标准库较少。没有文件系统，I/O流等没有标准API，在推进标准化过程仅限于浏览器端
- 没有标准接口。对于web服务器或数据库
- 缺乏包管理系统

## CommonJS规范

主要为了弥补当时JavaScript没有标准的缺陷，以达到像Python、Ruby、Java具备开发大型应用的基础能力

利用**CommonJS API**写出的应用可以具备跨宿主环境执行的能力，不仅可以开发客户端，还可以开发这些应用

- 服务端JavaScript应用程序
- 命令行工具
- 桌面图形界面应用程序
- 混合应用

### 模块引用

使用`require(path)`方法，用来引入一个模块到当前上下文中

### 模块定义

一个文件就相当于一个模块，使用`module.exports`导出模块

我们所编写的代码最终使用node执行的时候，会将代码包装进一个立即执行函数（IIFE）中，这样就能够起到**隔离作用域**效果

```js
(function(exports,require,module,__filename,__dirname){
	//我在模块文件中写的代码
})()
```

导出模块时可以使用`exports`或者`module.exports`，因为**exports**对象是**module**的一个属性

使用`exports`导出时只能使用`exports.xxx`这种形式，因为`exports`对象是通过**形参**传入，`exports = {}`这种赋值会**改变形参的引用**，不能改变作用域外的值

### 模块标识

就是传递给`require()`方法的参数

- 小驼峰命名的字符串
- 以`.`、`..`开头的相对路径
- 绝对路径
- 可以不带文件名后缀

## Node模块的实现

node模块的实现遵循CommonJS规范

### 引入模块的步骤

#### 路径分析

根据模块标识分析

- 核心模块

  `http`，`fs`，`path`等核心模块

  - 优先级仅次于缓存加载
  - 在node源代码编译过程中已经编译为二进制代码，加载过程最快

- .或者..开头的相对路径文件模块

  - require方法将路径转为索引，将**编译执行后的对象**结果放到缓存，以使得二次加载时更快

- 以/开头的绝对路径文件模块

- 非路径形式的文件模块

  自定义模块，非核心模块，也不是路径形式的模块。是以包的形式的模块，通过在**node_modules**文件夹中逐级查找

  - 加载速度最慢：类似于js原型链查找

#### 文件定位

- 扩展名分析

  对于无扩展名的文件，以**.js、.json、.node**的次序尝试补足

  这个过程需要调用**fs核心模块同步阻塞**判断文件是否存在，这会*引起性能问题*

- 目录和包的处理

  1. 分析扩展名，无果，却得到一个目录
  2. 在当前目录下查找**package.json**，这是**CommonJS包规范**定义的描述文件
  3. 通过`JSON.parse`解析出描述对象，取出`main`属性指定的文件名进行定位，文件名缺少扩展名，则进入拓展名分析步骤
  4. `main`指定文件错误，没有package.json文件，将index当做默认文件名，依次查找index.js、index.json、index.node
  5. 如果在目录分析过程中没有定位成功，则进入**下一个模块路径**进行查找。模块路径遍历完毕，都没有查找到目标文件，则会抛出查找失败异常

#### 编译执行

定位到具体文件

对于js文件，使用fs模块同步读取文件后执行编译，返回一个立即执行函数

对于node文件，因为这是C/C++编写的扩展文件，通过`process.dlopen`方法加载编译生成的文件，`process.dlopen`是通过**libuv**封装的，node模块无需编译，只有加载和执行的过程

对于json文件，fs模块通过读取后，`JSON.parse`解析结果返回

对于其他文件，都被当做js文件载入

编译成功的模块

文件路径作为索引**缓存**在**Module._cache**对象上，提高二次引入性能

### 模块分类

node提供的**核心模块**

- node源码编译过程中编译进**二进制执行文件**，node进程启动时，部分核心模块就被直接**加载进内存中**
- 可省略**文件定位**和**编译执行**
- 加载速度最快

用户编写的**文件模块**

- 运行时动态加载
- 按完整模块引入步骤

### 优先从缓存加载

缓存的是现有和执行后的对象

核心模块的缓存检查优先于文件模块

## 核心模块

## NPM与包

Node组织了自身的核心模块，也使得第三方文件模块可以有序地编写和使用。但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用。而在模块之外，包和NPM则是将模块联系起来的一种机制。 

### CommonJS包规范

在模块的基础上，进一步组织js代码

包的组成

- 包结构：组织包中的各种文件
- 包描述文件（package.json）：描述包的相关信息
  - bin：包作为**命令行工具**使用
  - main：`require`引入包是，优先检查这个字段，将其作为其余模块的**入口**

### npm常用功能

#### 安装依赖包

**全局安装**

通过全局模式安装的所有模块都被安装进一个统一目录

若node可执行文件的位置是`usr/local/bin/node`，则安装模块目录是`usr/local/lib/node_modules`

**从本地安装**

没有发布到npm上的包

为npm指定package.json文件所在的位置

**从非官方源安装**

通过为npm设置**registry**，可以从第三方源下载包

```bash
npm config set registry source-url
```



#### 钩子命令

#### 发布包

1. 编写模块
2. 初始化包描述文件
3. 注册包仓库账号
   - `npm adduser`注册账号
4. 上传包
   - `npm publish <folder>`
5. 安装包
6. 管理包权限
   - `npm owener`
7. 分析包
   - `npm ls`

## 模块系统

AMD：CommonJS规范的延伸；ReuqireJS；浏览器端

CMD：接近与Node对CommonJS规范的定义；SeaJS；浏览器端

UMD：兼容AMD和Commonjs，同时支持浏览器和服务端

CommonJS：读取磁盘中的模块；适合服务端；

ESM：ECMA2015引入的模块化标准