---
title: 构建Web应用
date: 2023-07-31
---

## 创建node服务器

```js
http.createServer((request,response)=>{
  response.writeHead(200,{'Content-Type':'text/plain'})
  response.end('hello world')
})
.listen(1337,'127.0.0.1')
```

对于Web应用而言，这是远达不到业务需求的，在具体业务中，可能有这些需求

- 请求方法的判断
- URL的路径解析
- URL中查询字符串解析
- cookie的解析
- basic认证
- 表单数据的解析
- 任意格式文件的上传处理
- 日志

### 请求方法

> req.method

RESTful

GET：查看资源

POST：更新资源

PUT：新建一个资源

DELETE：删除一个资源

### 路径解析

> `req.url`
>
> 包含`path`和`query`
>
> `hash`部分会被丢弃

通过`url.parse(req.url)`方法解析出URL对象

常见业务

- 静态文件服务器
- 根据路径捞选择控制器

### 查询字符串

路径`?`后面的query，通过`url.parse(req.url).query`获得查询字符串

`querystring`模块处理query，解析出JSON对象

`querystring.parse(url.parse(req.url).query)`

`url.parse()`也可以，需要传递第二个参数为true

`url.parse(req.url,true).query`

在一些中间件或者框架（koa、express）会将查询字符串转换，然后**挂载到请求对象**上供业务使用

`req.query = url.parse(req.url,true).query`

出现多次的key，value将会是一个数组，业务的判断一定要检查值是数组还是字符串，否则可能出现TypeError异常情况

### Cookie

HTTP是一个无状态协议，业务中常常需要状态，否则无法区分用户之间的身份，使用cookie可以标识和认证一个用户，这是最早的方案。

记录服务端和客户端的状态

cookie的处理如下

1. 服务端向客户端发送cookie

   通过**响应报文**设置cookie，如`res.setHeader('Set-Cookie',serialize('name','ken'))`

   在node中封装设置cookie方法

   ```js
   //组织将要发送cookie到客户端
   function serialize(name,val,opt){
   	var pairs= [ `${name}=${encode(val)}` ]
   	opt = opt || {}
   	if(opt.maxAge) pairs.push(`Max-Age=${opt.maxAge}`)
   	if(opt.expires) pairs.push(`Expires=${opt.expires.toUTCString}`)
   	if(opt.httpOnly) pairs.push('HttpOnly')
   	if(opt.path) pairs.push(`Path=${opt.path}`)
   	if(opt.domain) pairs.push(`Domain=${opt.domain}`)
   	if(opt.secure) pairs.push('Secure')
   	return pairs.join('; ')
   }
   ```

   

2. 客户端将cookie保存

3. 之后每次浏览器都会将cookie发向服务器端

​	**解析cookie为JSON对象**

```js
//解析从客户端请求带来的cookie
function parseCookie(cookie){
	var cookies = {}
	if(!cookie){
		return cookies
	}
	var list = cookie.split(';')
	list.forEach(item=>{
		var pair = item.split('=')
		cookie[pair[0].trim()] = pair[1]
	})
	return cookies
}
```



> req.headers.cookie，通过`parseCookie`解析成JSON后挂载到req.cookie供业务使用

**设置cookie的选项**

`path`：cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器不会发送这个cookie

`Expires/Max-Age`：告知浏览器何时过期；不设置，在关闭浏览器时丢弃这个cookie

- Expires：何时过期，UTC格式时间值
- Max-Age：多久过期，一般是设置多少秒过期

`HttpOnly`：为true，不允许前端修改，也不可见

`Secure`：为true，只有HTTPS有效

**性能影响**

减少cookie大小：设置的cookie过多，会导致包头较大，造成带宽浪费

为静态组件使用不同的域名：为不需要的cookie的组件换个域名可以减少无效cookie的传输

减少DNS查询

### session

解决cookie敏感数据，**数据只保留在服务器，客户端无法修改，也不需要每次被传递**

**实现session**

1. 基于cookie实现用户和数据的映射

   1. 使用cookie存放token

   2. 生成session

      ```js
      var sessions = {}
      var key = 'sid'
      var EXPIRES = 20*60*1000
      var generate = function(){
      	var session = {}
      	//设置sid，将会作为cookie的sid的值
      	session[key] = new Date().getTime() + Math.random()
      	session.cookie = {
      		expire: new Date().getTime() + EXPIRES
      	}
      	//以sid作为sessions的key，保存该用户的信息
      	sessions[session.sid] = session
      }
      ```

      

   3. 请求到来，检查cookie中的sid与服务端session数据

      ```js
      function(req,res){
      	// 根据cookie保存的sid值查找用户信息
      	var id = req.cookie[key]
      	if(!id){
      		req.session = generate()
      	}else{
      		//以sid为key取出sessions中的用户对象session
      		var session = sessions[id]
      		if(session){
      			if(session.cookie.expire>new Date().getTime()){
      				//更新超时时间
      				session.cookie.expire = new Date().getTime() + EXPIRES
      				req.session = session
      			}else{
      				//超时，删除旧数据，重新生成
      				delete sessions[id]
      				req.session = generate()
      			}
      		}else{
      			//口令不存在或过期
      			req.session = generate()
      		}
      	}
      	//后续的操作
      	handle(req,res)
      }
      ```

      

   4. 响应给客户端设置新的值

      ```js
      //hack响应对象的writeHead()方法，在它的内部注入cookie的逻辑
      const writeHead = res.writeHead
      res.writeHead = function(){
      	const cookies = res.getHead('Set-Cookie')
      	const session = serialize(key,req.session[key])
      	cookies = Array.isArray(cookies)? cookies.concat(session):[cookies,session]
      	res.setHeader('Set-Cookie',cookies)
      	//返回原来的writeHead方法
      	return writeHead.apply(this,arguments)
      }
      
      
      var handle = functoon(req,res){
      	if(!req.session.isVisit){
      		res.session.isVisit = true
      		res.writeHead(200)
      		res.end('welcome')
      	}else{
      		res.wirteHead(200)
      		res.end('welcome again')
      	}
      }
      
      ```

      

2. 通过查询字符串实现B&S数据对应

   1. 查询query中是否有sid
   2. 根据sid在session中查询用户对象
   3. 没有sid，生成并告诉浏览器跳转

   ```js
   var getUrl = function(_url,key,value){
   	var obj = url.parse(_url,true)
   	obj.query[key] = value
   	return url.format(obj)
   }
   function(req,res){
   	var redirect = function(url){
   		//浏览器要跳转的路径
   		res.setHeader('Location',url)
   		res.writeHead(302)
   		res.end()
   	}
   	var sid = req.query[key]
   	if(!sid){
   		var session = generate()
   		redirect(getUrl(req.url,key,session.sid))
   	}else{
   		var session = sessions[sid]
   		//更新过期时间，更新session，设置Location跳转
   		//过期，删除旧数据，重新生成，设置Location跳转
   		//口令不对，重新生成，设置Loaction跳转
   	}
   }
   ```

   

**session与内存的问题**

1. node有内存限制

   将数据存放在内存有很大的隐患，用户增多，就会触及到内存限制的上限

   内存中的数据量加大，必然引起垃圾回收的频繁扫描，引起性能问题

2. 进程不共享

   用户的session可能会引起错乱

**解决方法**

session集中化：将分散在多个进程的数据统一转移到集中的数据储存中

使用redis、memcached高效缓存

问题：会引起网络访问，访问网络中的数据要比访问本地磁盘中的数据速度要慢，涉及握手，传输，磁盘I/O等

仍采用高速缓存的理由

1. node与缓存服务保持**长连接**握手导致的延迟只影响初始化
2. 高速缓存直接在内存中进行数据储存和访问
3. 缓存服务器通常与node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小

**session与安全**

- 存放在客户端的口令被伪造盗用

  可以使用`cryto`工具加密口令

  ```js
  //加密
  var sign = function(val,secret){
  	return `
  		${val}
  		.
  		crypto.createHmac('sha256',secret)
  		.update(val)
  		.digest('base64')
  		.replace(/\=+$/,'')
  	`
  }
  
  //解密
  var unsign = function(val,secret){
  	var str = val.slice(0,val.lastIndexOf('.'))
  	return sign(str,secret) == val ? str: false
  }
  ```

  

- XSS漏洞

  用户的输入没有转义，而被直接**在浏览器执行**

  

























