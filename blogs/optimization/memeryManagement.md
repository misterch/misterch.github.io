---
title: 内存管理
date: 2024-05-08
tags:
 - 性能优化
---

```js
//申请内存
let obj = {}
//使用内存
obj.name = 'ben'
//释放内存
obj = null
```

## javascript中的垃圾回收（GC）

- javascript中内存管理是自动的
- 对象不再被**引用**时是垃圾
- 对象不能**从根上**访问到时是垃圾

## javascript中的可达对象

- 可以访问到的对象就是可达对象（引用、作用域链）
- 可达的标准就是从根出发是否能够被找到
- javascript中的**根**就可以理解为是**全局变量对象**



## javascript中的引用与可达

```js
// 一个对象被obj变量引用
// 从全局角度来看，obj可以从根上找到
let obj = {name:'xm'}
// {name:'xm'}被再次引用，引用数值变化了
let ali = obj
// obj断掉了与{name:'xm'}的引用，但{name:'xm'}仍然可达，因为ali还是引用了
obj = null
```

## GC定义与作用

- GC是一种机制，垃圾回收期完成具体的工作
- 工作的内容就是查找垃圾释放空间、回收空间
- 算法就是工作时查找和回收所遵循的规则

### 引用计数

**核心思想**：设置引用数，判断当前引用数是否为0

引用计数器

引用关系改变时修改引用数字，引用数字为0是立即回收

**优点**

- 发现垃圾时立即回收
- 最大限度减少程序暂停

**缺点**

- 无法回收循环引用的对象
- 时间开销大

### 标记清除

**核心思想：**分标记和清除两个阶段完成

遍历所有对象找标记活动对象

遍历所有对象清除没有标记对象

回收相应的空间

**优点**

相对于引用计算，解决了循环引用不能回收的问题

一些函数作用域内定义的变量且互相引用，函数调用结束后需要释放内部空间，因为局部空间的变量失去了与全局作用域上的连接，就无法在根下访问得到（不可达对象），不能完成标记；在内存回收时将没有标记的对象释放

**缺点**

空间碎片化，回收的垃圾对象，地址上是不连续的，浪费空间

不会立即回收垃圾对象

### 标记整理

- 标记整理可以看做是标记清楚的增强
- 标记阶段的操作和标记清除一致
- 清除阶段会先执行整理，移动对象位置

### 分代回收

V8引擎采用的垃圾回收思想（V8引擎的内存设有上限）

内存分为新生代和老生代，针对不同对象采用不同算法

**新生代对象**

- 小空间用于存储新生代对象（64位32M，32位16M）


- 新生代指的是存活时间较短的对象


回收实现

1. 回收过程采用复制算法+标记整理
2. 新生代内存区分为2个等大小空间
3. 使用空间为From，空闲空间为To
4. 活动对象存储于From空间
5. 标记整理后将活动对象拷贝至To
6. From与To交换空间完成释放

回收细节

- 拷贝过程中可能出现晋升
- 晋升就是将新生代对象移动至老生代
- 一轮GC还存活的新生代需要晋升
- To空间的使用率超过25%

**老生代对象**

- 大空间用于存储老生代对象（64位1.4G，32位700M）
- 老生代对象是指存活时间较长的对象（如全局变量，闭包中的变量）

回收实现

1. 主要采用标记清楚、标记整理、增量标记算法
2. 首先使用标记清除完成垃圾空间的回收（找到老生代对象中所有的活动对象进行标记，然后释放掉垃圾对象空间，这样就会存在空间碎片化的问题，但明显提升了速度）
3. 采用标记整理进行空间优化（当新生代区域要往老生代区域移动的时候，而且老生代区域**空间不足够**存储新生代移动过来的对象，则进行标记整理将碎片空间进行整理回收）
4. 采用增量标记进行回收效率优化

**细节对比**

- 新生代区域垃圾回收使用空间换时间
- 老生代区域垃圾回收不适合复制算法
- 标记增量（将整个垃圾回收操作拆分成多段组合进行，这样可以实现程序执行和垃圾回收交替进行，减少阻塞程序执行）

## 内存问题的外在体现

- 页面出现延迟加载或经常性暂停
- 页面持续性出现糟糕的性能
- 页面性能随时间延长越来越差

## 界定内存问题的标准

- 内存泄漏：内存使用持续升高
- 内存膨胀：在多数设备商都存在性能问题
- 频繁垃圾回收：通过内存变化图进行分析

## 监控内存的几种方式

1. 浏览器任务管理器

2. Timeline时序图记录

3. 堆快照查找分离DOM

   - 界面元素存活在DOM树上
   - 垃圾对象时的DOM节点：DOM树上脱离，JS代码中也没有引用该DOM节点
   - 分离状态的DOM节点：DOM树上脱离，但JS代码仍有引用，需要清除对分离DOM的引用

4. 判断是否存在频繁的垃圾回收

   - GC工作时应用程序是停止的
   - 频繁且过长的GC会导致应用假死
   - 用户使用中感知应用卡顿

   Timeline中频繁的上升下降

   任务管理器中数据频繁的增加减少

## 参考

拉勾教育-大前端高薪训练营（视频）

