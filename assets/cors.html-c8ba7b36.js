import{_ as a,o as s,c as n,a as e}from"./app-d4c6289a.js";const t={},r=e(`<h2 id="什么是跨域" tabindex="-1"><a class="header-anchor" href="#什么是跨域" aria-hidden="true">#</a> 什么是跨域</h2><p>主要是出于<strong>浏览器</strong>的同源策略限制，它是浏览器最核心也最基本的安全功能。</p><p>当一个请求url的 <strong>协议、域名、端口</strong> 三者之间任意一个与当前页面url不同即为跨域。</p><p>跨域限制其实已经接收到服务器的消息，但是浏览器因为安全原因不提供给本域名</p><p>发送请求的时候不可能拦截，因为浏览器不确保请求的服务器是否允许跨域</p><p>跨域请求默认情况下会被浏览器拦截，例如A网页向B服务器发起请求，除非A请求服务器出具标记说明可以获取B服务器的信息</p><h2 id="如何解决跨域" tabindex="-1"><a class="header-anchor" href="#如何解决跨域" aria-hidden="true">#</a> 如何解决跨域</h2><h3 id="jsonp" tabindex="-1"><a class="header-anchor" href="#jsonp" aria-hidden="true">#</a> jsonp</h3><p>基本原理是利用了HTML里script元素标签没有跨域限制 动态创建script标签，将src作为服务器地址，服务器返回一个callback接受返回的参数</p><h3 id="设置cors跨域资源共享" tabindex="-1"><a class="header-anchor" href="#设置cors跨域资源共享" aria-hidden="true">#</a> 设置cors跨域资源共享</h3><p>需要由后端设置</p><p>指定可以共享资源的地址</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;Access-Control-Allow-Origin&quot;</span><span class="token operator">:</span> <span class="token string">&quot;http://web.xxx.com&quot;</span> <span class="token comment">//可以指定地址</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>任意地址都能够访问</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;Access-Control-Allow-Origin&quot;</span><span class="token operator">:</span> <span class="token string">&quot;*&quot;</span> <span class="token comment">//也可以使用通配符 任何地址都能访问 安全性不高</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="代理" tabindex="-1"><a class="header-anchor" href="#代理" aria-hidden="true">#</a> 代理</h3><p>使用<strong>vite proxy、webpack proxy、node</strong>都能够实现代理</p><p>因为只有浏览器才会有跨域限制，可以通过本地开发服务器配置代理（由服务器请求另一个服务器）请求目标地址获得信息，将目标服务器的信息带回来给浏览器</p><h3 id="反向代理" tabindex="-1"><a class="header-anchor" href="#反向代理" aria-hidden="true">#</a> 反向代理</h3><p>使用 <code>Nginx</code>配置反向代理，拦截请求，再将其转发到目标服务器</p><p><code>proxy_pass</code>用来设置被代理服务器地址，可以是主机名称，IP地址加端口号</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#当跨域时，nginx拦截/api开头的请求，将其转发到http:localhost:9000;解决跨域问题</span>
location /api <span class="token punctuation">{</span>
	proxy_pass	http://localhost:9000<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,22),i=[r];function o(c,p){return s(),n("div",null,i)}const l=a(t,[["render",o],["__file","cors.html.vue"]]);export{l as default};
