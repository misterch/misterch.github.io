import{_ as a,o as i,c as n,a as l}from"./app-d4c6289a.js";const s={},e=l(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//申请内存</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">//使用内存</span>
obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;ben&#39;</span>
<span class="token comment">//释放内存</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="javascript中的垃圾回收-gc" tabindex="-1"><a class="header-anchor" href="#javascript中的垃圾回收-gc" aria-hidden="true">#</a> javascript中的垃圾回收（GC）</h2><ul><li>javascript中内存管理是自动的</li><li>对象不再被<strong>引用</strong>时是垃圾</li><li>对象不能<strong>从根上</strong>访问到时是垃圾</li></ul><h2 id="javascript中的可达对象" tabindex="-1"><a class="header-anchor" href="#javascript中的可达对象" aria-hidden="true">#</a> javascript中的可达对象</h2><ul><li>可以访问到的对象就是可达对象（引用、作用域链）</li><li>可达的标准就是从根出发是否能够被找到</li><li>javascript中的<strong>根</strong>就可以理解为是<strong>全局变量对象</strong></li></ul><h2 id="javascript中的引用与可达" tabindex="-1"><a class="header-anchor" href="#javascript中的引用与可达" aria-hidden="true">#</a> javascript中的引用与可达</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 一个对象被obj变量引用</span>
<span class="token comment">// 从全局角度来看，obj可以从根上找到</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;xm&#39;</span><span class="token punctuation">}</span>
<span class="token comment">// {name:&#39;xm&#39;}被再次引用，引用数值变化了</span>
<span class="token keyword">let</span> ali <span class="token operator">=</span> obj
<span class="token comment">// obj断掉了与{name:&#39;xm&#39;}的引用，但{name:&#39;xm&#39;}仍然可达，因为ali还是引用了</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="gc定义与作用" tabindex="-1"><a class="header-anchor" href="#gc定义与作用" aria-hidden="true">#</a> GC定义与作用</h2><ul><li>GC是一种机制，垃圾回收期完成具体的工作</li><li>工作的内容就是查找垃圾释放空间、回收空间</li><li>算法就是工作时查找和回收所遵循的规则</li></ul><h3 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h3><p><strong>核心思想</strong>：设置引用数，判断当前引用数是否为0</p><p>引用计数器</p><p>引用关系改变时修改引用数字，引用数字为0是立即回收</p><p><strong>优点</strong></p><ul><li>发现垃圾时立即回收</li><li>最大限度减少程序暂停</li></ul><p><strong>缺点</strong></p><ul><li>无法回收循环引用的对象</li><li>时间开销大</li></ul><h3 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h3><p>**核心思想：**分标记和清除两个阶段完成</p><p>遍历所有对象找标记活动对象</p><p>遍历所有对象清除没有标记对象</p><p>回收相应的空间</p><p><strong>优点</strong></p><p>相对于引用计算，解决了循环引用不能回收的问题</p><p>一些函数作用域内定义的变量且互相引用，函数调用结束后需要释放内部空间，因为局部空间的变量失去了与全局作用域上的连接，就无法在根下访问得到（不可达对象），不能完成标记；在内存回收时将没有标记的对象释放</p><p><strong>缺点</strong></p><p>空间碎片化，回收的垃圾对象，地址上是不连续的，浪费空间</p><p>不会立即回收垃圾对象</p><h3 id="标记整理" tabindex="-1"><a class="header-anchor" href="#标记整理" aria-hidden="true">#</a> 标记整理</h3><ul><li>标记整理可以看做是标记清楚的增强</li><li>标记阶段的操作和标记清除一致</li><li>清除阶段会先执行整理，移动对象位置</li></ul><h3 id="分代回收" tabindex="-1"><a class="header-anchor" href="#分代回收" aria-hidden="true">#</a> 分代回收</h3><p>V8引擎采用的垃圾回收思想（V8引擎的内存设有上限）</p><p>内存分为新生代和老生代，针对不同对象采用不同算法</p><p><strong>新生代对象</strong></p><ul><li><p>小空间用于存储新生代对象（64位32M，32位16M）</p></li><li><p>新生代指的是存活时间较短的对象</p></li></ul><p>回收实现</p><ol><li>回收过程采用复制算法+标记整理</li><li>新生代内存区分为2个等大小空间</li><li>使用空间为From，空闲空间为To</li><li>活动对象存储于From空间</li><li>标记整理后将活动对象拷贝至To</li><li>From与To交换空间完成释放</li></ol><p>回收细节</p><ul><li>拷贝过程中可能出现晋升</li><li>晋升就是将新生代对象移动至老生代</li><li>一轮GC还存活的新生代需要晋升</li><li>To空间的使用率超过25%</li></ul><p><strong>老生代对象</strong></p><ul><li>大空间用于存储老生代对象（64位1.4G，32位700M）</li><li>老生代对象是指存活时间较长的对象（如全局变量，闭包中的变量）</li></ul><p>回收实现</p><ol><li>主要采用标记清楚、标记整理、增量标记算法</li><li>首先使用标记清除完成垃圾空间的回收（找到老生代对象中所有的活动对象进行标记，然后释放掉垃圾对象空间，这样就会存在空间碎片化的问题，但明显提升了速度）</li><li>采用标记整理进行空间优化（当新生代区域要往老生代区域移动的时候，而且老生代区域<strong>空间不足够</strong>存储新生代移动过来的对象，则进行标记整理将碎片空间进行整理回收）</li><li>采用增量标记进行回收效率优化</li></ol><p><strong>细节对比</strong></p><ul><li>新生代区域垃圾回收使用空间换时间</li><li>老生代区域垃圾回收不适合复制算法</li><li>标记增量（将整个垃圾回收操作拆分成多段组合进行，这样可以实现程序执行和垃圾回收交替进行，减少阻塞程序执行）</li></ul><h2 id="内存问题的外在体现" tabindex="-1"><a class="header-anchor" href="#内存问题的外在体现" aria-hidden="true">#</a> 内存问题的外在体现</h2><ul><li>页面出现延迟加载或经常性暂停</li><li>页面持续性出现糟糕的性能</li><li>页面性能随时间延长越来越差</li></ul><h2 id="界定内存问题的标准" tabindex="-1"><a class="header-anchor" href="#界定内存问题的标准" aria-hidden="true">#</a> 界定内存问题的标准</h2><ul><li>内存泄漏：内存使用持续升高</li><li>内存膨胀：在多数设备商都存在性能问题</li><li>频繁垃圾回收：通过内存变化图进行分析</li></ul><h2 id="监控内存的几种方式" tabindex="-1"><a class="header-anchor" href="#监控内存的几种方式" aria-hidden="true">#</a> 监控内存的几种方式</h2><ol><li><p>浏览器任务管理器</p></li><li><p>Timeline时序图记录</p></li><li><p>堆快照查找分离DOM</p><ul><li>界面元素存活在DOM树上</li><li>垃圾对象时的DOM节点：DOM树上脱离，JS代码中也没有引用该DOM节点</li><li>分离状态的DOM节点：DOM树上脱离，但JS代码仍有引用，需要清除对分离DOM的引用</li></ul></li><li><p>判断是否存在频繁的垃圾回收</p><ul><li>GC工作时应用程序是停止的</li><li>频繁且过长的GC会导致应用假死</li><li>用户使用中感知应用卡顿</li></ul><p>Timeline中频繁的上升下降</p><p>任务管理器中数据频繁的增加减少</p></li></ol><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2><p>拉勾教育-大前端高薪训练营（视频）</p>`,53),r=[e];function p(t,o){return i(),n("div",null,r)}const d=a(s,[["render",p],["__file","memeryManagement.html.vue"]]);export{d as default};
