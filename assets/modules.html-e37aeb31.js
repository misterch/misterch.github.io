import{_ as t,o as r,c as s,a as d,b as e,d as o}from"./app-d4c6289a.js";const a={},c=d('<h2 id="为什么要模块化" tabindex="-1"><a class="header-anchor" href="#为什么要模块化" aria-hidden="true">#</a> 为什么要模块化</h2><ol><li>大大提高代码的可维护性，可被其他地方引用或用用别人写好的模块或引用node内置模块</li><li>可以避免函数名和变量名冲突</li></ol><h2 id="模块规范的定义" tabindex="-1"><a class="header-anchor" href="#模块规范的定义" aria-hidden="true">#</a> 模块规范的定义</h2><p>一个js文件就是一个模块，<strong>模块的作用域是私有的</strong>，内部定义的变量和函数只在当前的文件可以用</p><p>当外部需要用到模块中的变量或函数，需要导出</p><h2 id="导出方式" tabindex="-1"><a class="header-anchor" href="#导出方式" aria-hidden="true">#</a> 导出方式</h2><h3 id="module-exports" tabindex="-1"><a class="header-anchor" href="#module-exports" aria-hidden="true">#</a> module.exports</h3><p><code>module.exports.prop=&#39;value&#39;</code>这种方式，则会映射到<code>exports</code>对象</p><h3 id="exports" tabindex="-1"><a class="header-anchor" href="#exports" aria-hidden="true">#</a> exports</h3><p><code>exports</code>是<code>module.exports</code>的引用</p><p>在<code>exports</code>对象上可以挂在任何属性和方法，且都反映到<code>module.exports</code>上</p><p>终端中没有<code>exports</code>对象</p>',12),l=e("div",{class:"custom-container tip"},[e("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[e("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[e("circle",{cx:"12",cy:"12",r:"9"}),e("path",{d:"M12 8h.01"}),e("path",{d:"M11 12h1v4h1"})])]),e("p",{class:"custom-container-title"},"TIP"),e("p",null,[e("code",null,"exports = {}"),o("是不正确的使用方式，这会切断与"),e("code",null,"module.exports"),o("的联系")]),e("p",null,[e("code",null,"exports.key = val"),o("这种才是正确的方式")])],-1),n=e("h2",{id:"this的指向",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#this的指向","aria-hidden":"true"},"#"),o(" this的指向")],-1),i=e("p",null,"在模块文件中，this指向exports",-1),h=e("p",null,"在终端中，this指向global",-1),p=[c,l,n,i,h];function u(x,_){return r(),s("div",null,p)}const f=t(a,[["render",u],["__file","modules.html.vue"]]);export{f as default};
