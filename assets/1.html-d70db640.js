import{_ as o,r as a,o as n,c as t,b as e,d as i,e as s,a as d}from"./app-d4c6289a.js";const l={},h=d('<h2 id="node特点" tabindex="-1"><a class="header-anchor" href="#node特点" aria-hidden="true">#</a> node特点</h2><h3 id="异步i-o" tabindex="-1"><a class="header-anchor" href="#异步i-o" aria-hidden="true">#</a> 异步I/O</h3><ul><li>I/O高并发</li><li>可并行</li></ul><h3 id="事件驱动" tabindex="-1"><a class="header-anchor" href="#事件驱动" aria-hidden="true">#</a> 事件驱动</h3><p>事件与回调函数</p><h3 id="单线程" tabindex="-1"><a class="header-anchor" href="#单线程" aria-hidden="true">#</a> 单线程</h3><p><strong>优点</strong></p><ol><li>不用处处在意<strong>状态</strong>的同步问题</li><li>没有<strong>死锁</strong></li><li>没有<strong>线程上下文交换</strong>带来的性能上的开销</li></ol><p><strong>缺点</strong></p><ol><li><strong>无法利用多核CPU</strong>（node不适合CPU密集型，处理CPU密集型用到cluster）</li><li><strong>错误会引起整个应用退出</strong>，考验应用健壮性</li><li>大量计算占用CPU导致无法继续调用异步I/O</li></ol><p><strong>解决中大计算量问题</strong></p><p>前端：web workers</p><ol><li>创建工作<strong>线程</strong>来计算，解决js大量计算阻塞UI渲染问题</li><li>工作线程通过<strong>消息传递</strong>来运行结果，也不能访问主线程中的UI</li></ol><p>后端：child_prosess(子进程)</p><ol><li>将计算分发到各个<strong>子进程</strong>，然后通过进程之间的<strong>事件消息</strong>传递结果</li></ol><h3 id="跨平台" tabindex="-1"><a class="header-anchor" href="#跨平台" aria-hidden="true">#</a> 跨平台</h3><p>基于<strong>libuv</strong>实现跨平台</p><p>在<strong>操作系统</strong>和<strong>node上层模块系统</strong>之间构建一层平台层架构</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddde8e7be0a941a3a01cb20f7909b05c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt=""></p><h2 id="基调" tabindex="-1"><a class="header-anchor" href="#基调" aria-hidden="true">#</a> 基调</h2><p>事件驱动，异步I/O，单线程</p><ul><li>作为服务器端处理客户端带来的<strong>高并发请求</strong></li><li>作为客户端向网络中的各个应用进行并发请求</li></ul><p>与之相近，<strong>Nginx</strong>面向那个客户端管理连接的强大能力</p><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h2><h3 id="i-o密集型" tabindex="-1"><a class="header-anchor" href="#i-o密集型" aria-hidden="true">#</a> I/O密集型</h3><p>I/O密集的优势主要在于Node利用<strong>事件循环</strong>的处理能力，而不是启动每一个线程为每一个请</p><p>求服务，资源占用极少。</p><h3 id="cpu密集型" tabindex="-1"><a class="header-anchor" href="#cpu密集型" aria-hidden="true">#</a> CPU密集型</h3><p>因为js单线程的原因，若有<strong>长时间运行的计算</strong>模糊调至CPU时间片不能释放，是的后续I/O无法发起</p><p>但是适当调整和<strong>分解</strong>大型运算任务<strong>为多个小任务</strong>，使得运算能够<strong>适时释放</strong>，不阻塞I/O调用的发起，这样既可同时享受到<strong>并行异步I/O</strong>的好处，又能充分利用CPU。</p><h3 id="分布式应用" tabindex="-1"><a class="header-anchor" href="#分布式应用" aria-hidden="true">#</a> 分布式应用</h3><p>Node<strong>高效利用并行I/O</strong>的过程，也是高效使用数据库的过程</p><h2 id="node的使用者" tabindex="-1"><a class="header-anchor" href="#node的使用者" aria-hidden="true">#</a> node的使用者</h2><ol><li>前后端编程语言环境统一</li><li>高性能I/O用于<strong>实时应用</strong>，过socket.io实现实时通知的功能</li><li>并行I/O可以更高效地利用分布式环境</li><li>并行I/O，有效利用稳定接口提升Web渲染能力</li><li>云计算平台提供Node支持</li><li>游戏开发</li><li>工具类应用，webpack，vite等</li></ol><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',35),c={href:"https://book.douban.com/subject/25768396/",target:"_blank",rel:"noopener noreferrer"};function g(p,u){const r=a("ExternalLinkIcon");return n(),t("div",null,[h,e("p",null,[e("a",c,[i("深入浅出Node.js (豆瓣) (douban.com)"),s(r)])])])}const f=o(l,[["render",g],["__file","1.html.vue"]]);export{f as default};
