import{_ as e,o as n,c as a,a as o}from"./app-d4c6289a.js";const s={},i=o(`<p>对于早期的javascript，ECMA的规范很薄弱，有一下缺点</p><ul><li>没有模块系统</li><li>标准库较少。没有文件系统，I/O流等没有标准API，在推进标准化过程仅限于浏览器端</li><li>没有标准接口。对于web服务器或数据库</li><li>缺乏包管理系统</li></ul><h2 id="commonjs规范" tabindex="-1"><a class="header-anchor" href="#commonjs规范" aria-hidden="true">#</a> CommonJS规范</h2><p>主要为了弥补当时JavaScript没有标准的缺陷，以达到像Python、Ruby、Java具备开发大型应用的基础能力</p><p>利用<strong>CommonJS API</strong>写出的应用可以具备跨宿主环境执行的能力，不仅可以开发客户端，还可以开发这些应用</p><ul><li>服务端JavaScript应用程序</li><li>命令行工具</li><li>桌面图形界面应用程序</li><li>混合应用</li></ul><h3 id="模块引用" tabindex="-1"><a class="header-anchor" href="#模块引用" aria-hidden="true">#</a> 模块引用</h3><p>使用<code>require(path)</code>方法，用来引入一个模块到当前上下文中</p><h3 id="模块定义" tabindex="-1"><a class="header-anchor" href="#模块定义" aria-hidden="true">#</a> 模块定义</h3><p>一个文件就相当于一个模块，使用<code>module.exports</code>导出模块</p><p>我们所编写的代码最终使用node执行的时候，会将代码包装进一个立即执行函数（IIFE）中，这样就能够起到<strong>隔离作用域</strong>效果</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span>require<span class="token punctuation">,</span>module<span class="token punctuation">,</span>__filename<span class="token punctuation">,</span>__dirname</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//我在模块文件中写的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>导出模块时可以使用<code>exports</code>或者<code>module.exports</code>，因为<strong>exports</strong>对象是<strong>module</strong>的一个属性</p><p>使用<code>exports</code>导出时只能使用<code>exports.xxx</code>这种形式，因为<code>exports</code>对象是通过<strong>形参</strong>传入，<code>exports = {}</code>这种赋值会<strong>改变形参的引用</strong>，不能改变作用域外的值</p><h3 id="模块标识" tabindex="-1"><a class="header-anchor" href="#模块标识" aria-hidden="true">#</a> 模块标识</h3><p>就是传递给<code>require()</code>方法的参数</p><ul><li>小驼峰命名的字符串</li><li>以<code>.</code>、<code>..</code>开头的相对路径</li><li>绝对路径</li><li>可以不带文件名后缀</li></ul><h2 id="node模块的实现" tabindex="-1"><a class="header-anchor" href="#node模块的实现" aria-hidden="true">#</a> Node模块的实现</h2><p>node模块的实现遵循CommonJS规范</p><h3 id="引入模块的步骤" tabindex="-1"><a class="header-anchor" href="#引入模块的步骤" aria-hidden="true">#</a> 引入模块的步骤</h3><h4 id="路径分析" tabindex="-1"><a class="header-anchor" href="#路径分析" aria-hidden="true">#</a> 路径分析</h4><p>根据模块标识分析</p><ul><li><p>核心模块</p><p><code>http</code>，<code>fs</code>，<code>path</code>等核心模块</p><ul><li>优先级仅次于缓存加载</li><li>在node源代码编译过程中已经编译为二进制代码，加载过程最快</li></ul></li><li><p>.或者..开头的相对路径文件模块</p><ul><li>require方法将路径转为索引，将<strong>编译执行后的对象</strong>结果放到缓存，以使得二次加载时更快</li></ul></li><li><p>以/开头的绝对路径文件模块</p></li><li><p>非路径形式的文件模块</p><p>自定义模块，非核心模块，也不是路径形式的模块。是以包的形式的模块，通过在<strong>node_modules</strong>文件夹中逐级查找</p><ul><li>加载速度最慢：类似于js原型链查找</li></ul></li></ul><h4 id="文件定位" tabindex="-1"><a class="header-anchor" href="#文件定位" aria-hidden="true">#</a> 文件定位</h4><ul><li><p>扩展名分析</p><p>对于无扩展名的文件，以**.js、.json、.node**的次序尝试补足</p><p>这个过程需要调用<strong>fs核心模块同步阻塞</strong>判断文件是否存在，这会<em>引起性能问题</em></p></li><li><p>目录和包的处理</p><ol><li>分析扩展名，无果，却得到一个目录</li><li>在当前目录下查找<strong>package.json</strong>，这是<strong>CommonJS包规范</strong>定义的描述文件</li><li>通过<code>JSON.parse</code>解析出描述对象，取出<code>main</code>属性指定的文件名进行定位，文件名缺少扩展名，则进入拓展名分析步骤</li><li><code>main</code>指定文件错误，没有package.json文件，将index当做默认文件名，依次查找index.js、index.json、index.node</li><li>如果在目录分析过程中没有定位成功，则进入<strong>下一个模块路径</strong>进行查找。模块路径遍历完毕，都没有查找到目标文件，则会抛出查找失败异常</li></ol></li></ul><h4 id="编译执行" tabindex="-1"><a class="header-anchor" href="#编译执行" aria-hidden="true">#</a> 编译执行</h4><p>定位到具体文件</p><p>对于js文件，使用fs模块同步读取文件后执行编译，返回一个立即执行函数</p><p>对于node文件，因为这是C/C++编写的扩展文件，通过<code>process.dlopen</code>方法加载编译生成的文件，<code>process.dlopen</code>是通过<strong>libuv</strong>封装的，node模块无需编译，只有加载和执行的过程</p><p>对于json文件，fs模块通过读取后，<code>JSON.parse</code>解析结果返回</p><p>对于其他文件，都被当做js文件载入</p><p>编译成功的模块</p><p>文件路径作为索引<strong>缓存</strong>在<strong>Module._cache</strong>对象上，提高二次引入性能</p><h3 id="模块分类" tabindex="-1"><a class="header-anchor" href="#模块分类" aria-hidden="true">#</a> 模块分类</h3><p>node提供的<strong>核心模块</strong></p><ul><li>node源码编译过程中编译进<strong>二进制执行文件</strong>，node进程启动时，部分核心模块就被直接<strong>加载进内存中</strong></li><li>可省略<strong>文件定位</strong>和<strong>编译执行</strong></li><li>加载速度最快</li></ul><p>用户编写的<strong>文件模块</strong></p><ul><li>运行时动态加载</li><li>按完整模块引入步骤</li></ul><h3 id="优先从缓存加载" tabindex="-1"><a class="header-anchor" href="#优先从缓存加载" aria-hidden="true">#</a> 优先从缓存加载</h3><p>缓存的是现有和执行后的对象</p><p>核心模块的缓存检查优先于文件模块</p><h2 id="核心模块" tabindex="-1"><a class="header-anchor" href="#核心模块" aria-hidden="true">#</a> 核心模块</h2><h2 id="npm与包" tabindex="-1"><a class="header-anchor" href="#npm与包" aria-hidden="true">#</a> NPM与包</h2><p>Node组织了自身的核心模块，也使得第三方文件模块可以有序地编写和使用。但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用。而在模块之外，包和NPM则是将模块联系起来的一种机制。</p><h3 id="commonjs包规范" tabindex="-1"><a class="header-anchor" href="#commonjs包规范" aria-hidden="true">#</a> CommonJS包规范</h3><p>在模块的基础上，进一步组织js代码</p><p>包的组成</p><ul><li>包结构：组织包中的各种文件</li><li>包描述文件（package.json）：描述包的相关信息 <ul><li>bin：包作为<strong>命令行工具</strong>使用</li><li>main：<code>require</code>引入包是，优先检查这个字段，将其作为其余模块的<strong>入口</strong></li></ul></li></ul><h3 id="npm常用功能" tabindex="-1"><a class="header-anchor" href="#npm常用功能" aria-hidden="true">#</a> npm常用功能</h3><h4 id="安装依赖包" tabindex="-1"><a class="header-anchor" href="#安装依赖包" aria-hidden="true">#</a> 安装依赖包</h4><p><strong>全局安装</strong></p><p>通过全局模式安装的所有模块都被安装进一个统一目录</p><p>若node可执行文件的位置是<code>usr/local/bin/node</code>，则安装模块目录是<code>usr/local/lib/node_modules</code></p><p><strong>从本地安装</strong></p><p>没有发布到npm上的包</p><p>为npm指定package.json文件所在的位置</p><p><strong>从非官方源安装</strong></p><p>通过为npm设置<strong>registry</strong>，可以从第三方源下载包</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry source-url
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="钩子命令" tabindex="-1"><a class="header-anchor" href="#钩子命令" aria-hidden="true">#</a> 钩子命令</h4><h4 id="发布包" tabindex="-1"><a class="header-anchor" href="#发布包" aria-hidden="true">#</a> 发布包</h4><ol><li>编写模块</li><li>初始化包描述文件</li><li>注册包仓库账号 <ul><li><code>npm adduser</code>注册账号</li></ul></li><li>上传包 <ul><li><code>npm publish &lt;folder&gt;</code></li></ul></li><li>安装包</li><li>管理包权限 <ul><li><code>npm owener</code></li></ul></li><li>分析包 <ul><li><code>npm ls</code></li></ul></li></ol><h2 id="模块系统" tabindex="-1"><a class="header-anchor" href="#模块系统" aria-hidden="true">#</a> 模块系统</h2><p>AMD：CommonJS规范的延伸；ReuqireJS；浏览器端</p><p>CMD：接近与Node对CommonJS规范的定义；SeaJS；浏览器端</p><p>UMD：兼容AMD和Commonjs，同时支持浏览器和服务端</p><p>CommonJS：读取磁盘中的模块；适合服务端；</p><p>ESM：ECMA2015引入的模块化标准</p>`,68),d=[i];function r(l,p){return n(),a("div",null,d)}const c=e(s,[["render",r],["__file","2.html.vue"]]);export{c as default};
